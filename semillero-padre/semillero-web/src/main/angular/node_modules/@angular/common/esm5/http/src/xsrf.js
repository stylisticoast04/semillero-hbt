/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as tslib_1 from "tslib";
import { DOCUMENT, ɵparseCookieValue as parseCookieValue } from '@angular/common';
import { Inject, Injectable, InjectionToken, PLATFORM_ID } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
export var XSRF_COOKIE_NAME = new InjectionToken('XSRF_COOKIE_NAME');
export var XSRF_HEADER_NAME = new InjectionToken('XSRF_HEADER_NAME');
/**
 * Retrieves the current XSRF token to use with the next outgoing request.
 *
 * @publicApi
 */
var HttpXsrfTokenExtractor = /** @class */ (function () {
    function HttpXsrfTokenExtractor() {
    }
    return HttpXsrfTokenExtractor;
}());
export { HttpXsrfTokenExtractor };
/**
 * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.
 */
var HttpXsrfCookieExtractor = /** @class */ (function () {
    function HttpXsrfCookieExtractor(doc, platform, cookieName) {
        this.doc = doc;
        this.platform = platform;
        this.cookieName = cookieName;
        this.lastCookieString = '';
        this.lastToken = null;
        /**
         * @internal for testing
         */
        this.parseCount = 0;
    }
    HttpXsrfCookieExtractor.prototype.getToken = function () {
        if (this.platform === 'server') {
            return null;
        }
        var cookieString = this.doc.cookie || '';
        if (cookieString !== this.lastCookieString) {
            this.parseCount++;
            this.lastToken = parseCookieValue(cookieString, this.cookieName);
            this.lastCookieString = cookieString;
        }
        return this.lastToken;
    };
    HttpXsrfCookieExtractor = tslib_1.__decorate([
        tslib_1.__param(0, Inject(DOCUMENT)), tslib_1.__param(1, Inject(PLATFORM_ID)),
        tslib_1.__param(2, Inject(XSRF_COOKIE_NAME)),
        tslib_1.__metadata("design:paramtypes", [Object, String, String])
    ], HttpXsrfCookieExtractor);
HttpXsrfCookieExtractor.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: HttpXsrfCookieExtractor, factory: function HttpXsrfCookieExtractor_Factory(t) { return new (t || HttpXsrfCookieExtractor)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(XSRF_COOKIE_NAME)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(HttpXsrfCookieExtractor, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [XSRF_COOKIE_NAME]
            }] }]; }, { doc: [], platform: [], cookieName: [], lastCookieString: [], lastToken: [], parseCount: [], getToken: [] });
    return HttpXsrfCookieExtractor;
}());
export { HttpXsrfCookieExtractor };
/**
 * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.
 */
var HttpXsrfInterceptor = /** @class */ (function () {
    function HttpXsrfInterceptor(tokenService, headerName) {
        this.tokenService = tokenService;
        this.headerName = headerName;
    }
    HttpXsrfInterceptor.prototype.intercept = function (req, next) {
        var lcUrl = req.url.toLowerCase();
        // Skip both non-mutating requests and absolute URLs.
        // Non-mutating requests don't require a token, and absolute URLs require special handling
        // anyway as the cookie set
        // on our origin is not the same as the token expected by another origin.
        if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||
            lcUrl.startsWith('https://')) {
            return next.handle(req);
        }
        var token = this.tokenService.getToken();
        // Be careful not to overwrite an existing header of the same name.
        if (token !== null && !req.headers.has(this.headerName)) {
            req = req.clone({ headers: req.headers.set(this.headerName, token) });
        }
        return next.handle(req);
    };
    HttpXsrfInterceptor = tslib_1.__decorate([
        tslib_1.__param(1, Inject(XSRF_HEADER_NAME)),
        tslib_1.__metadata("design:paramtypes", [HttpXsrfTokenExtractor, String])
    ], HttpXsrfInterceptor);
HttpXsrfInterceptor.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: HttpXsrfInterceptor, factory: function HttpXsrfInterceptor_Factory(t) { return new (t || HttpXsrfInterceptor)(ɵngcc0.ɵɵinject(HttpXsrfTokenExtractor), ɵngcc0.ɵɵinject(XSRF_HEADER_NAME)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(HttpXsrfInterceptor, [{
        type: Injectable
    }], function () { return [{ type: HttpXsrfTokenExtractor }, { type: String, decorators: [{
                type: Inject,
                args: [XSRF_HEADER_NAME]
            }] }]; }, { tokenService: [], headerName: [], intercept: [] });
    return HttpXsrfInterceptor;
}());
export { HttpXsrfInterceptor };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1NlbWlsbGVyby9NYXRlcmlhbHNlc2lvbjMvc2VtaWxsZXJvLWhidC9zZW1pbGxlcm8tcGFkcmUvc2VtaWxsZXJvLXdlYi9zcmMvbWFpbi9hbmd1bGFyL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vZXNtNS9odHRwL3NyYy94c3JmLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tEQXdDa0QsQUFDN0I7Ozs7Ozs7Ozs7Ozs7Ozs7O29JQUlXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0E2QmMsQUFDekI7Ozs7Ozs7Ozs7MkVBR08iLCJmaWxlIjoieHNyZi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBET0NVTUVOVCwgybVwYXJzZUNvb2tpZVZhbHVlIGFzIHBhcnNlQ29va2llVmFsdWUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgUExBVEZPUk1fSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmV4cG9ydCB2YXIgWFNSRl9DT09LSUVfTkFNRSA9IG5ldyBJbmplY3Rpb25Ub2tlbignWFNSRl9DT09LSUVfTkFNRScpO1xuZXhwb3J0IHZhciBYU1JGX0hFQURFUl9OQU1FID0gbmV3IEluamVjdGlvblRva2VuKCdYU1JGX0hFQURFUl9OQU1FJyk7XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBYU1JGIHRva2VuIHRvIHVzZSB3aXRoIHRoZSBuZXh0IG91dGdvaW5nIHJlcXVlc3QuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG52YXIgSHR0cFhzcmZUb2tlbkV4dHJhY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwWHNyZlRva2VuRXh0cmFjdG9yKCkge1xuICAgIH1cbiAgICByZXR1cm4gSHR0cFhzcmZUb2tlbkV4dHJhY3Rvcjtcbn0oKSk7XG5leHBvcnQgeyBIdHRwWHNyZlRva2VuRXh0cmFjdG9yIH07XG4vKipcbiAqIGBIdHRwWHNyZlRva2VuRXh0cmFjdG9yYCB3aGljaCByZXRyaWV2ZXMgdGhlIHRva2VuIGZyb20gYSBjb29raWUuXG4gKi9cbnZhciBIdHRwWHNyZkNvb2tpZUV4dHJhY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdHRwWHNyZkNvb2tpZUV4dHJhY3Rvcihkb2MsIHBsYXRmb3JtLCBjb29raWVOYW1lKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gcGxhdGZvcm07XG4gICAgICAgIHRoaXMuY29va2llTmFtZSA9IGNvb2tpZU5hbWU7XG4gICAgICAgIHRoaXMubGFzdENvb2tpZVN0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLmxhc3RUb2tlbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyc2VDb3VudCA9IDA7XG4gICAgfVxuICAgIEh0dHBYc3JmQ29va2llRXh0cmFjdG9yLnByb3RvdHlwZS5nZXRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0gPT09ICdzZXJ2ZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29va2llU3RyaW5nID0gdGhpcy5kb2MuY29va2llIHx8ICcnO1xuICAgICAgICBpZiAoY29va2llU3RyaW5nICE9PSB0aGlzLmxhc3RDb29raWVTdHJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VDb3VudCsrO1xuICAgICAgICAgICAgdGhpcy5sYXN0VG9rZW4gPSBwYXJzZUNvb2tpZVZhbHVlKGNvb2tpZVN0cmluZywgdGhpcy5jb29raWVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENvb2tpZVN0cmluZyA9IGNvb2tpZVN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0VG9rZW47XG4gICAgfTtcbiAgICBIdHRwWHNyZkNvb2tpZUV4dHJhY3RvciA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIEluamVjdGFibGUoKSxcbiAgICAgICAgdHNsaWJfMS5fX3BhcmFtKDAsIEluamVjdChET0NVTUVOVCkpLCB0c2xpYl8xLl9fcGFyYW0oMSwgSW5qZWN0KFBMQVRGT1JNX0lEKSksXG4gICAgICAgIHRzbGliXzEuX19wYXJhbSgyLCBJbmplY3QoWFNSRl9DT09LSUVfTkFNRSkpLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBTdHJpbmcsIFN0cmluZ10pXG4gICAgXSwgSHR0cFhzcmZDb29raWVFeHRyYWN0b3IpO1xuICAgIHJldHVybiBIdHRwWHNyZkNvb2tpZUV4dHJhY3Rvcjtcbn0oKSk7XG5leHBvcnQgeyBIdHRwWHNyZkNvb2tpZUV4dHJhY3RvciB9O1xuLyoqXG4gKiBgSHR0cEludGVyY2VwdG9yYCB3aGljaCBhZGRzIGFuIFhTUkYgdG9rZW4gdG8gZWxpZ2libGUgb3V0Z29pbmcgcmVxdWVzdHMuXG4gKi9cbnZhciBIdHRwWHNyZkludGVyY2VwdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0dHBYc3JmSW50ZXJjZXB0b3IodG9rZW5TZXJ2aWNlLCBoZWFkZXJOYW1lKSB7XG4gICAgICAgIHRoaXMudG9rZW5TZXJ2aWNlID0gdG9rZW5TZXJ2aWNlO1xuICAgICAgICB0aGlzLmhlYWRlck5hbWUgPSBoZWFkZXJOYW1lO1xuICAgIH1cbiAgICBIdHRwWHNyZkludGVyY2VwdG9yLnByb3RvdHlwZS5pbnRlcmNlcHQgPSBmdW5jdGlvbiAocmVxLCBuZXh0KSB7XG4gICAgICAgIHZhciBsY1VybCA9IHJlcS51cmwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gU2tpcCBib3RoIG5vbi1tdXRhdGluZyByZXF1ZXN0cyBhbmQgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgLy8gTm9uLW11dGF0aW5nIHJlcXVlc3RzIGRvbid0IHJlcXVpcmUgYSB0b2tlbiwgYW5kIGFic29sdXRlIFVSTHMgcmVxdWlyZSBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgIC8vIGFueXdheSBhcyB0aGUgY29va2llIHNldFxuICAgICAgICAvLyBvbiBvdXIgb3JpZ2luIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgdG9rZW4gZXhwZWN0ZWQgYnkgYW5vdGhlciBvcmlnaW4uXG4gICAgICAgIGlmIChyZXEubWV0aG9kID09PSAnR0VUJyB8fCByZXEubWV0aG9kID09PSAnSEVBRCcgfHwgbGNVcmwuc3RhcnRzV2l0aCgnaHR0cDovLycpIHx8XG4gICAgICAgICAgICBsY1VybC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuU2VydmljZS5nZXRUb2tlbigpO1xuICAgICAgICAvLyBCZSBjYXJlZnVsIG5vdCB0byBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgaGVhZGVyIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAgICAgIGlmICh0b2tlbiAhPT0gbnVsbCAmJiAhcmVxLmhlYWRlcnMuaGFzKHRoaXMuaGVhZGVyTmFtZSkpIHtcbiAgICAgICAgICAgIHJlcSA9IHJlcS5jbG9uZSh7IGhlYWRlcnM6IHJlcS5oZWFkZXJzLnNldCh0aGlzLmhlYWRlck5hbWUsIHRva2VuKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICB9O1xuICAgIEh0dHBYc3JmSW50ZXJjZXB0b3IgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIHRzbGliXzEuX19wYXJhbSgxLCBJbmplY3QoWFNSRl9IRUFERVJfTkFNRSkpLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSHR0cFhzcmZUb2tlbkV4dHJhY3RvciwgU3RyaW5nXSlcbiAgICBdLCBIdHRwWHNyZkludGVyY2VwdG9yKTtcbiAgICByZXR1cm4gSHR0cFhzcmZJbnRlcmNlcHRvcjtcbn0oKSk7XG5leHBvcnQgeyBIdHRwWHNyZkludGVyY2VwdG9yIH07XG4iXX0=