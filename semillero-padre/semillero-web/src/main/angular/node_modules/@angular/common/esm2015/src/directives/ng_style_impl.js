/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ElementRef, Injectable, KeyValueDiffers, Renderer2 } from '@angular/core';
import { StylingDiffer } from './styling_differ';
/**
 * Used as a token for an injected service within the NgStyle directive.
 *
 * NgStyle behaves differenly whether or not VE is being used or not. If
 * present then the legacy ngClass diffing algorithm will be used as an
 * injected service. Otherwise the new diffing algorithm (which delegates
 * to the `[style]` binding) will be used. This toggle behavior is done so
 * via the ivy_switch mechanism.
 * @abstract
 */
import * as ɵngcc0 from '@angular/core';
export class NgStyleImpl {
}
if (false) {
    /**
     * @abstract
     * @return {?}
     */
    NgStyleImpl.prototype.getValue = function () { };
    /**
     * @abstract
     * @param {?} value
     * @return {?}
     */
    NgStyleImpl.prototype.setNgStyle = function (value) { };
    /**
     * @abstract
     * @return {?}
     */
    NgStyleImpl.prototype.applyChanges = function () { };
}
export class NgStyleR2Impl {
    /**
     * @param {?} _ngEl
     * @param {?} _differs
     * @param {?} _renderer
     */
    constructor(_ngEl, _differs, _renderer) {
        this._ngEl = _ngEl;
        this._differs = _differs;
        this._renderer = _renderer;
    }
    /**
     * @return {?}
     */
    getValue() { return null; }
    /**
     * A map of style properties, specified as colon-separated
     * key-value pairs.
     * * The key is a style name, with an optional `.<unit>` suffix
     *    (such as 'top.px', 'font-style.em').
     * * The value is an expression to be evaluated.
     * @param {?} values
     * @return {?}
     */
    setNgStyle(values) {
        this._ngStyle = values;
        if (!this._differ && values) {
            this._differ = this._differs.find(values).create();
        }
    }
    /**
     * Applies the new styles if needed.
     * @return {?}
     */
    applyChanges() {
        if (this._differ) {
            /** @type {?} */
            const changes = this._differ.diff(this._ngStyle);
            if (changes) {
                this._applyChanges(changes);
            }
        }
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    _applyChanges(changes) {
        changes.forEachRemovedItem((/**
         * @param {?} record
         * @return {?}
         */
        (record) => this._setStyle(record.key, null)));
        changes.forEachAddedItem((/**
         * @param {?} record
         * @return {?}
         */
        (record) => this._setStyle(record.key, record.currentValue)));
        changes.forEachChangedItem((/**
         * @param {?} record
         * @return {?}
         */
        (record) => this._setStyle(record.key, record.currentValue)));
    }
    /**
     * @private
     * @param {?} nameAndUnit
     * @param {?} value
     * @return {?}
     */
    _setStyle(nameAndUnit, value) {
        const [name, unit] = nameAndUnit.split('.');
        value = value != null && unit ? `${value}${unit}` : value;
        if (value != null) {
            this._renderer.setStyle(this._ngEl.nativeElement, name, (/** @type {?} */ (value)));
        }
        else {
            this._renderer.removeStyle(this._ngEl.nativeElement, name);
        }
    }
}
NgStyleR2Impl.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: NgStyleR2Impl, factory: function NgStyleR2Impl_Factory(t) { return new (t || NgStyleR2Impl)(ɵngcc0.ɵɵinject(ElementRef), ɵngcc0.ɵɵinject(KeyValueDiffers), ɵngcc0.ɵɵinject(Renderer2)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgStyleR2Impl, [{
        type: Injectable
    }], function () { return [{ type: ElementRef }, { type: KeyValueDiffers }, { type: Renderer2 }]; }, { constructor: [], _ngEl: [], _differs: [], _renderer: [], getValue: [], setNgStyle: [], _ngStyle: [], _differ: [], applyChanges: [], _applyChanges: [], _setStyle: [] });
/** @nocollapse */
NgStyleR2Impl.ctorParameters = () => [
    { type: ElementRef },
    { type: KeyValueDiffers },
    { type: Renderer2 }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgStyleR2Impl.prototype._ngStyle;
    /**
     * @type {?}
     * @private
     */
    NgStyleR2Impl.prototype._differ;
    /**
     * @type {?}
     * @private
     */
    NgStyleR2Impl.prototype._ngEl;
    /**
     * @type {?}
     * @private
     */
    NgStyleR2Impl.prototype._differs;
    /**
     * @type {?}
     * @private
     */
    NgStyleR2Impl.prototype._renderer;
}
export class NgStyleR3Impl {
    constructor() {
        this._differ = new StylingDiffer('NgStyle', 8 /* AllowUnits */);
        this._value = null;
    }
    /**
     * @return {?}
     */
    getValue() { return this._value; }
    /**
     * @param {?} value
     * @return {?}
     */
    setNgStyle(value) { this._differ.setValue(value); }
    /**
     * @return {?}
     */
    applyChanges() {
        if (this._differ.hasValueChanged()) {
            this._value = this._differ.value;
        }
    }
}
NgStyleR3Impl.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: NgStyleR3Impl, factory: function NgStyleR3Impl_Factory(t) { return new (t || NgStyleR3Impl)(); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgStyleR3Impl, [{
        type: Injectable
    }], function () { return []; }, { constructor: [], _differ: [], _value: [], getValue: [], setNgStyle: [], applyChanges: [] });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgStyleR3Impl.prototype._differ;
    /**
     * @type {?}
     * @private
     */
    NgStyleR3Impl.prototype._value;
}
// the implementation for both NgClassR2Impl and NgClassR3Impl are
// not ivy_switch'd away, instead they are only hooked up into the
// DI via NgStyle's directive's provider property.
/** @type {?} */
export const NgStyleImplProvider__PRE_R3__ = {
    provide: NgStyleImpl,
    useClass: NgStyleR2Impl
};
/** @type {?} */
export const NgStyleImplProvider__POST_R3__ = {
    provide: NgStyleImpl,
    useClass: NgStyleR3Impl
};
/** @type {?} */
export const NgStyleImplProvider = NgStyleImplProvider__POST_R3__;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1NlbWlsbGVyby9NYXRlcmlhbHNlc2lvbjMvc2VtaWxsZXJvLWhidC9zZW1pbGxlcm8tcGFkcmUvc2VtaWxsZXJvLXdlYi9zcmMvbWFpbi9hbmd1bGFyL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21tb24vZXNtMjAxNS9zcmMvZGlyZWN0aXZlcy9uZ19zdHlsZV9pbXBsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFHQyxpUkFHQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0RELGlJQUdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBMkJpQyw4QkFBNkIiLCJmaWxlIjoibmdfc3R5bGVfaW1wbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdGFibGUsIEtleVZhbHVlRGlmZmVycywgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdHlsaW5nRGlmZmVyIH0gZnJvbSAnLi9zdHlsaW5nX2RpZmZlcic7XG4vKipcbiAqIFVzZWQgYXMgYSB0b2tlbiBmb3IgYW4gaW5qZWN0ZWQgc2VydmljZSB3aXRoaW4gdGhlIE5nU3R5bGUgZGlyZWN0aXZlLlxuICpcbiAqIE5nU3R5bGUgYmVoYXZlcyBkaWZmZXJlbmx5IHdoZXRoZXIgb3Igbm90IFZFIGlzIGJlaW5nIHVzZWQgb3Igbm90LiBJZlxuICogcHJlc2VudCB0aGVuIHRoZSBsZWdhY3kgbmdDbGFzcyBkaWZmaW5nIGFsZ29yaXRobSB3aWxsIGJlIHVzZWQgYXMgYW5cbiAqIGluamVjdGVkIHNlcnZpY2UuIE90aGVyd2lzZSB0aGUgbmV3IGRpZmZpbmcgYWxnb3JpdGhtICh3aGljaCBkZWxlZ2F0ZXNcbiAqIHRvIHRoZSBgW3N0eWxlXWAgYmluZGluZykgd2lsbCBiZSB1c2VkLiBUaGlzIHRvZ2dsZSBiZWhhdmlvciBpcyBkb25lIHNvXG4gKiB2aWEgdGhlIGl2eV9zd2l0Y2ggbWVjaGFuaXNtLlxuICogQGFic3RyYWN0XG4gKi9cbmV4cG9ydCBjbGFzcyBOZ1N0eWxlSW1wbCB7XG59XG5pZiAoZmFsc2UpIHtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nU3R5bGVJbXBsLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOZ1N0eWxlSW1wbC5wcm90b3R5cGUuc2V0TmdTdHlsZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdTdHlsZUltcGwucHJvdG90eXBlLmFwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHsgfTtcbn1cbmV4cG9ydCBjbGFzcyBOZ1N0eWxlUjJJbXBsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9uZ0VsXG4gICAgICogQHBhcmFtIHs/fSBfZGlmZmVyc1xuICAgICAqIEBwYXJhbSB7P30gX3JlbmRlcmVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX25nRWwsIF9kaWZmZXJzLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fbmdFbCA9IF9uZ0VsO1xuICAgICAgICB0aGlzLl9kaWZmZXJzID0gX2RpZmZlcnM7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldFZhbHVlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIHN0eWxlIHByb3BlcnRpZXMsIHNwZWNpZmllZCBhcyBjb2xvbi1zZXBhcmF0ZWRcbiAgICAgKiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogKiBUaGUga2V5IGlzIGEgc3R5bGUgbmFtZSwgd2l0aCBhbiBvcHRpb25hbCBgLjx1bml0PmAgc3VmZml4XG4gICAgICogICAgKHN1Y2ggYXMgJ3RvcC5weCcsICdmb250LXN0eWxlLmVtJykuXG4gICAgICogKiBUaGUgdmFsdWUgaXMgYW4gZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWQuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldE5nU3R5bGUodmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX25nU3R5bGUgPSB2YWx1ZXM7XG4gICAgICAgIGlmICghdGhpcy5fZGlmZmVyICYmIHZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHZhbHVlcykuY3JlYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgbmV3IHN0eWxlcyBpZiBuZWVkZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBhcHBseUNoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaWZmZXIpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLl9uZ1N0eWxlKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfYXBwbHlDaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlY29yZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgKHJlY29yZCkgPT4gdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgbnVsbCkpKTtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIChyZWNvcmQpID0+IHRoaXMuX3NldFN0eWxlKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpKSk7XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaENoYW5nZWRJdGVtKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIChyZWNvcmQpID0+IHRoaXMuX3NldFN0eWxlKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBuYW1lQW5kVW5pdFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9zZXRTdHlsZShuYW1lQW5kVW5pdCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgW25hbWUsIHVuaXRdID0gbmFtZUFuZFVuaXQuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSAhPSBudWxsICYmIHVuaXQgPyBgJHt2YWx1ZX0ke3VuaXR9YCA6IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fbmdFbC5uYXRpdmVFbGVtZW50LCBuYW1lLCAoLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVTdHlsZSh0aGlzLl9uZ0VsLm5hdGl2ZUVsZW1lbnQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuTmdTdHlsZVIySW1wbC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5OZ1N0eWxlUjJJbXBsLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogRWxlbWVudFJlZiB9LFxuICAgIHsgdHlwZTogS2V5VmFsdWVEaWZmZXJzIH0sXG4gICAgeyB0eXBlOiBSZW5kZXJlcjIgfVxuXTtcbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTmdTdHlsZVIySW1wbC5wcm90b3R5cGUuX25nU3R5bGU7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBOZ1N0eWxlUjJJbXBsLnByb3RvdHlwZS5fZGlmZmVyO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTmdTdHlsZVIySW1wbC5wcm90b3R5cGUuX25nRWw7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBOZ1N0eWxlUjJJbXBsLnByb3RvdHlwZS5fZGlmZmVycztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE5nU3R5bGVSMkltcGwucHJvdG90eXBlLl9yZW5kZXJlcjtcbn1cbmV4cG9ydCBjbGFzcyBOZ1N0eWxlUjNJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZGlmZmVyID0gbmV3IFN0eWxpbmdEaWZmZXIoJ05nU3R5bGUnLCA4IC8qIEFsbG93VW5pdHMgKi8pO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZ2V0VmFsdWUoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldE5nU3R5bGUodmFsdWUpIHsgdGhpcy5fZGlmZmVyLnNldFZhbHVlKHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgYXBwbHlDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlmZmVyLmhhc1ZhbHVlQ2hhbmdlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2RpZmZlci52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5nU3R5bGVSM0ltcGwuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IEluamVjdGFibGUgfVxuXTtcbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTmdTdHlsZVIzSW1wbC5wcm90b3R5cGUuX2RpZmZlcjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE5nU3R5bGVSM0ltcGwucHJvdG90eXBlLl92YWx1ZTtcbn1cbi8vIHRoZSBpbXBsZW1lbnRhdGlvbiBmb3IgYm90aCBOZ0NsYXNzUjJJbXBsIGFuZCBOZ0NsYXNzUjNJbXBsIGFyZVxuLy8gbm90IGl2eV9zd2l0Y2gnZCBhd2F5LCBpbnN0ZWFkIHRoZXkgYXJlIG9ubHkgaG9va2VkIHVwIGludG8gdGhlXG4vLyBESSB2aWEgTmdTdHlsZSdzIGRpcmVjdGl2ZSdzIHByb3ZpZGVyIHByb3BlcnR5LlxuLyoqIEB0eXBlIHs/fSAqL1xuZXhwb3J0IGNvbnN0IE5nU3R5bGVJbXBsUHJvdmlkZXJfX1BSRV9SM19fID0ge1xuICAgIHByb3ZpZGU6IE5nU3R5bGVJbXBsLFxuICAgIHVzZUNsYXNzOiBOZ1N0eWxlUjJJbXBsXG59O1xuLyoqIEB0eXBlIHs/fSAqL1xuZXhwb3J0IGNvbnN0IE5nU3R5bGVJbXBsUHJvdmlkZXJfX1BPU1RfUjNfXyA9IHtcbiAgICBwcm92aWRlOiBOZ1N0eWxlSW1wbCxcbiAgICB1c2VDbGFzczogTmdTdHlsZVIzSW1wbFxufTtcbi8qKiBAdHlwZSB7P30gKi9cbmV4cG9ydCBjb25zdCBOZ1N0eWxlSW1wbFByb3ZpZGVyID0gTmdTdHlsZUltcGxQcm92aWRlcl9fUFJFX1IzX187XG4iXX0=